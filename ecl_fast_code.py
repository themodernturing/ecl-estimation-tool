# -*- coding: utf-8 -*-
"""ECL Fast Code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U8K-5Xo2pXytYOsADdIMP-NWqxGslrmB
"""

# Cell 1: Install & Imports
!pip install --quiet pandas scikit-learn gradio joblib

import pandas as pd
import numpy as np
import joblib
import gradio as gr
import os

os.makedirs('models', exist_ok=True)

# Cell 4: Robust load & prepare Recovery data
import pandas as pd

def load_recovery(path):
    # 1. Read without header to detect the header row dynamically
    raw = pd.read_excel(path, sheet_name='Invoice wise recovery', header=None)

    # 2. Find the first row index containing "Invoice Date"
    header_row = raw.apply(
        lambda row: row.astype(str).str.contains('Invoice Date', case=False, na=False).any(),
        axis=1
    ).idxmax()

    # 3. Now read again using the detected header row
    df = pd.read_excel(path, sheet_name='Invoice wise recovery', header=header_row)

    # 4. Drop fully empty columns
    df = df.dropna(axis=1, how='all')

    # 5. Strip whitespace from any string column names
    df = df.rename(columns=lambda c: c.strip() if isinstance(c, str) else c)

    # 6. Parse dates and numeric fields
    df['Invoice Date']    = pd.to_datetime(df['Invoice Date'], errors='coerce')
    df['Due Date']        = pd.to_datetime(df['Due Date'], errors='coerce')
    df['Receipt Date']    = pd.to_datetime(df['Receipt Date'], errors='coerce')
    df['Invoice Amount']  = pd.to_numeric(df['Invoice Amount'], errors='coerce')
    df['Amount received'] = pd.to_numeric(df['Amount received'], errors='coerce')

    # 7. Compute LGD and related flags
    df['Loss Amount']   = df['Invoice Amount'] - df['Amount received']
    df['LGD']           = df['Loss Amount'] / df['Invoice Amount']
    df['Days Past Due'] = (
        df['Receipt Date'].fillna(pd.Timestamp.today())
        - df['Due Date']
    ).dt.days
    df['Default Flag']  = (
        (df['Amount received'] < df['Invoice Amount']) &
        (df['Days Past Due'] > 90)
    ).astype(int)

    return df

# Load recovery data
recovery = load_recovery('/content/Data Template - ECL Model (1).xlsx')

# Quick check
print("Recovery columns:", recovery.columns.tolist())
print("Sample rows:\n", recovery.head())

# Cell 5: Merge Aging and Recovery as-of
def merge_data(aging_wide, recovery):
    rec_sorted = recovery.sort_values('Invoice Date')
    age_sorted = aging_wide.sort_values('Month end')
    merged = pd.merge_asof(
        left=rec_sorted, right=age_sorted,
        left_on='Invoice Date', right_on='Month end',
        by='Segment', direction='backward'
    ).fillna(0)
    return merged

# Merge datasets
merged = merge_data(aging_wide, recovery)

# Cell 6: Train PD and LGD models
def train_models(merged, bucket_cols):
    features = ['Days Past Due'] + bucket_cols

    # Train PD model (Logistic Regression)
    X = merged[features]
    y = merged['Default Flag']
    Xtr, Xte, ytr, yte = train_test_split(X, y, stratify=y, test_size=0.3, random_state=42)
    pd_model = LogisticRegression(max_iter=1000)
    pd_model.fit(Xtr, ytr)

    # Train LGD model (Random Forest) on defaulted invoices
    df_def = merged[merged['Default Flag']==1]
    X_lgd = df_def[features]
    y_lgd = df_def['LGD']
    Xltr, Xlte, yltr, ylte = train_test_split(X_lgd, y_lgd, test_size=0.3, random_state=42)
    lgd_model = RandomForestRegressor(n_estimators=100, random_state=42)
    lgd_model.fit(Xltr, yltr)

    # Persist models
    joblib.dump(pd_model, 'models/pd_model.joblib')
    joblib.dump(lgd_model, 'models/lgd_model.joblib')

    return pd_model, lgd_model, features

# Train and save models
pd_model, lgd_model, feat_cols = train_models(merged, buckets)

# Cell 7: ECL calculation with scenarios & discounting
def calculate_ecl(pd_score, lgd_score, ead, eir):
    scenarios = {
        "Central":  (1.0, 1.0, 0.6),
        "Upside":   (0.8, 0.9, 0.2),
        "Downside": (1.2, 1.1, 0.2),
    }
    rows = []
    weighted_sum = 0.0
    for name, (p_mult, l_mult, weight) in scenarios.items():
        ecl_val = pd_score * p_mult * lgd_score * l_mult * ead
        rows.append((f"ECL_{name}", round(ecl_val, 2)))
        weighted_sum += weight * ecl_val
    rows.append(("Weighted_ECL", round(weighted_sum, 2)))
    rows.append(("Discounted_ECL", round(weighted_sum / (1 + eir), 2)))
    return pd.DataFrame(rows, columns=["Metric","Value"])

# Cell 8: Gradio – Accountant View interface
# Reload models (if needed)
pd_model = joblib.load('models/pd_model.joblib')
lgd_model = joblib.load('models/lgd_model.joblib')

def accountant_interface(segment, days_past_due, ead, eir):
    # Fetch latest aging profile for the given segment
    latest_profile = aging_wide[aging_wide['Segment']==segment].sort_values('Month end').iloc[-1]
    X_in = [days_past_due] + [latest_profile[b] for b in buckets]
    X_arr = np.array(X_in).reshape(1, -1)

    # Predict PD and LGD
    pd_score  = float(pd_model.predict_proba(X_arr)[:,1])
    lgd_score = float(lgd_model.predict(X_arr))

    # Compute ECL results
    ecl_df = calculate_ecl(pd_score, lgd_score, ead, eir)

    # Prepend PD & LGD for transparency
    header_df = pd.DataFrame([
        ("PD", round(pd_score,4)),
        ("LGD", round(lgd_score,4))
    ], columns=["Metric","Value"])
    return pd.concat([header_df, ecl_df], ignore_index=True)

iface = gr.Interface(
    fn=accountant_interface,
    inputs=[
        gr.Dropdown(list(aging_wide['Segment'].unique()), label="Customer Segment"),
        gr.Number(label="Days Past Due", value=0, precision=0),
        gr.Number(label="Invoice Amount (EAD)", value=100000),
        gr.Number(label="Effective Interest Rate (EIR)", value=0.05, precision=4),
    ],
    outputs=gr.Dataframe(headers=["Metric","Value"]),
    title="ECL Calculator – Accountant View",
    description="Provide invoice details; PD and LGD are computed automatically."
)

iface.launch(share=True)

